From: =?UTF-8?q?Marco=20Trevisan=20=28Trevi=C3=B1o=29?= <mail@3v1n0.net>
Date: Tue, 18 Apr 2023 22:07:37 +0200
Subject: display: Set compositor selection earlier on XWayland

When the X11 display is actually XWayland there's no point to delay the
compositor selection, given that mutter itself is the compositor and
doing this may cause the first X11 client that starts not to receive the
right information (and in some cases misbehave).

Since some toolkits are not handling the compositor selection changes
properly at later times, let's make their life easier by just
initializing the selection as early as the other X11 properties, given
that in this case there's nothing to replace.

Currently the upstream MR on which this patch is based includes 7
commits. After consultation with Marco Trevisan only the first 4 of
those commits are included in this patch.

Origin: https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/2970
Bug: https://gitlab.gnome.org/GNOME/mutter/-/issues/2472
Bug-Ubuntu: https://launchpad.net/bugs/1987976
---

diff --git a/src/core/display.c b/src/core/display.c
index 0ee95c0f09208cb08a9fcd1e088c729c305cb160..eca1c0fcc496ac1cbc591bfc352d6c0a4656c773 100644
--- a/src/core/display.c
+++ b/src/core/display.c
@@ -762,7 +762,6 @@ meta_display_init_x11_finish (MetaDisplay   *display,
   if (!display->display_opening)
     {
       g_signal_emit (display, display_signals[X11_DISPLAY_OPENED], 0);
-      meta_x11_display_set_cm_selection (x11_display);
       meta_display_manage_all_xwindows (display);
       meta_compositor_redirect_x11_windows (display->compositor);
     }
diff --git a/src/tests/meson.build b/src/tests/meson.build
index 3768b83dabb15fd5fcbc7526a26d5ef142bc6107..4342a3d65ce11f29fd3df645d61ad0429504d22f 100644
--- a/src/tests/meson.build
+++ b/src/tests/meson.build
@@ -242,6 +242,7 @@ test_cases += [
     'name': 'monitor-unit',
     'suite': 'backend',
     'sources': [ 'monitor-unit-tests.c', ],
+    'depends': [test_client],
   },
   {
     'name': 'monitor-utils',
@@ -253,6 +254,7 @@ test_cases += [
     'flaky': true,
     'suite': 'compositor',
     'sources': [ 'stage-view-tests.c', ],
+    'depends': [test_client],
   },
   {
     'name': 'anonymous-file',
@@ -319,6 +321,7 @@ if have_native_tests
       'name': 'pointer-constraints',
       'suite': 'backends/native',
       'sources': [ 'native-pointer-constraints.c' ],
+      'depends': [test_client],
     },
     {
       'name': 'ref-test-sanity',
@@ -460,14 +463,29 @@ if have_native_tests
         wayland_protocol_files['mutter-x11-interop']['protocol-code'],
         built_dbus_sources['meta-dbus-service-channel'],
       ],
+      'depends': [test_client],
     },
   ]
   if have_xwayland
+    x11_compositor_checker = executable('x11-compositor-checker',
+      sources: ['x11-compositor-checker.c'],
+      c_args: [
+        tests_c_args,
+      ],
+      dependencies: [
+        x11_dep,
+      ],
+      install: have_installed_tests,
+      install_dir: mutter_installed_tests_libexecdir,
+      install_rpath: pkglibdir,
+    )
+
     test_cases += [
       {
         'name': 'xwayland',
         'suite': 'wayland',
         'flaky': host_machine.cpu_family() == 'arm',
+        'depends': [test_client, x11_compositor_checker],
         'sources': [
           'xwayland-tests.c',
         ],
@@ -505,6 +523,7 @@ if have_native_tests
       suite: ['core', 'mutter/' + test_case['suite']]
         + (test_case.get('flaky', false) ? ['flaky'] : []),
       env: test_env,
+      depends: test_case.get('depends', []),
       is_parallel: false,
       timeout: 60,
     )
diff --git a/src/tests/test-client.c b/src/tests/test-client.c
index a468e6137b64a56cadc616e1ef86fdda8e6abbba..020f89cb87c6c7e26e030c430d9ed408ce131aa5 100644
--- a/src/tests/test-client.c
+++ b/src/tests/test-client.c
@@ -1003,6 +1003,10 @@ main(int argc, char **argv)
   gtk_init (NULL, NULL);
 
   screen = gdk_screen_get_default ();
+
+  if (!wayland)
+    g_assert_true (gdk_screen_is_composited (screen));
+
   provider = gtk_css_provider_new ();
   static const char *no_decoration_css =
     "decoration {"
diff --git a/src/tests/x11-compositor-checker.c b/src/tests/x11-compositor-checker.c
new file mode 100644
index 0000000000000000000000000000000000000000..07e67ebef1b6d0fdfc09ca6a2d25db4c3a1f5705
--- /dev/null
+++ b/src/tests/x11-compositor-checker.c
@@ -0,0 +1,50 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
+/*
+ * Copyright (C) 2022 Alan Jenkins.
+ * Copyright (C) 2023 Canonical Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <stdio.h>
+#include <X11/Xlib.h>
+#include <X11/Xutil.h>
+
+static int
+has_compositor (Display *dpy,
+                int      screen)
+{
+  char prop_name[20];
+
+  snprintf (prop_name, 20, "_NET_WM_CM_S%d", screen);
+  return XGetSelectionOwner (dpy, XInternAtom (dpy, prop_name, False)) != None;
+}
+
+int
+main (void)
+{
+  Display *dpy = XOpenDisplay ("");
+
+  if (has_compositor (dpy, XDefaultScreen (dpy)))
+    {
+      printf ("X11 Compositor is available for display %s.%d\n",
+              DisplayString (dpy), XDefaultScreen (dpy));
+      return 0;
+    }
+
+  printf ("NO X11 Compositor is available for display %s:%d\n",
+          DisplayString (dpy), XDefaultScreen (dpy));
+
+  return 1;
+}
diff --git a/src/tests/xwayland-tests.c b/src/tests/xwayland-tests.c
index dc3608b5e6c6a3840275c63ffcbac9a03db4c05d..cb2fd6c9d5c127f2c00943a03029350a2ca38dcf 100644
--- a/src/tests/xwayland-tests.c
+++ b/src/tests/xwayland-tests.c
@@ -247,9 +247,68 @@ meta_test_hammer_activate (void)
   meta_test_client_destroy (wayland_client);
 }
 
+static void
+compositor_check_proc_async (GObject      *source_object,
+                             GAsyncResult *res,
+                             gpointer      user_data)
+{
+  g_autoptr (GError) error = NULL;
+  GMainLoop *loop = user_data;
+
+  g_subprocess_wait_check_finish (G_SUBPROCESS (source_object), res, &error);
+  g_assert_no_error (error);
+  g_main_loop_quit (loop);
+}
+
+static void
+meta_test_xwayland_compositor_selection (void)
+{
+  g_autoptr (GError) error = NULL;
+  g_autoptr (GSubprocessLauncher) launcher = NULL;
+  g_autoptr (GSubprocess) subprocess = NULL;
+  g_autoptr (GMainLoop) loop = NULL;
+  MetaDisplay *display = meta_context_get_display (test_context);
+  MetaWaylandCompositor *compositor;
+  const char *x11_display_name;
+  const char *x11_compositor_checker;
+
+  g_assert_null (meta_display_get_x11_display (display));
+
+  g_assert (meta_is_wayland_compositor ());
+  compositor = meta_context_get_wayland_compositor (test_context);
+  x11_display_name = meta_wayland_get_public_xwayland_display_name (compositor);
+  g_assert_nonnull (x11_display_name);
+
+  launcher = g_subprocess_launcher_new (G_SUBPROCESS_FLAGS_NONE);
+  g_subprocess_launcher_setenv (launcher,
+                                "DISPLAY", x11_display_name,
+                                TRUE);
+
+  x11_compositor_checker = g_test_build_filename (G_TEST_BUILT,
+                                                  "src",
+                                                  "tests",
+                                                  "x11-compositor-checker",
+                                                  NULL);
+
+  subprocess = g_subprocess_launcher_spawn (launcher,
+                                            &error,
+                                            x11_compositor_checker,
+                                            NULL);
+  g_assert_no_error (error);
+
+  loop = g_main_loop_new (NULL, FALSE);
+  g_subprocess_wait_check_async (subprocess, NULL,
+                                 compositor_check_proc_async, loop);
+  g_main_loop_run (loop);
+
+  g_assert_nonnull (meta_display_get_x11_display (display));
+}
+
 static void
 init_tests (void)
 {
+  g_test_add_func ("/backends/xwayland/compositor/selection",
+                   meta_test_xwayland_compositor_selection);
   g_test_add_func ("/backends/xwayland/restart/selection",
                    meta_test_xwayland_restart_selection);
   g_test_add_func ("/backends/xwayland/crash/only-x11",
diff --git a/src/x11/meta-x11-display.c b/src/x11/meta-x11-display.c
index 3efd81acd52526e1e101c2f9d8e3e3b96e0b8b4a..892f03230d4242658bc8df9b0c8bfde2678db148 100644
--- a/src/x11/meta-x11-display.c
+++ b/src/x11/meta-x11-display.c
@@ -736,6 +736,11 @@ take_manager_selection (MetaX11Display *x11_display,
     {
       XEvent event;
 
+#ifdef HAVE_XWAYLAND
+      if (meta_is_wayland_compositor ())
+        g_return_val_if_reached (new_owner);
+#endif
+
       /* We sort of block infinitely here which is probably lame. */
 
       meta_verbose ("Waiting for old window manager to exit");
@@ -1430,6 +1435,11 @@ meta_x11_display_new (MetaDisplay  *display,
   x11_display->wm_sn_atom = wm_sn_atom;
   x11_display->wm_sn_timestamp = timestamp;
 
+#ifdef HAVE_XWAYLAND
+  if (meta_is_wayland_compositor ())
+    meta_x11_display_set_cm_selection (x11_display);
+#endif
+
   init_event_masks (x11_display);
 
   meta_x11_display_init_frames_client (x11_display);
