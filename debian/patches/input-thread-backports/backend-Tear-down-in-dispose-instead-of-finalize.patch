From: =?utf-8?q?Jonas_=C3=85dahl?= <jadahl@gmail.com>
Date: Tue, 19 Jan 2021 22:14:01 +0100
Subject: backend: Tear down in dispose() instead of finalize()

This means backend implementations can have more control of the order of
how things are destroyed. To be precise, this will, in the next commit,
allow us to destroy the logind integration after the clutter backend
thus the libinput owning seat, that uses the logind integration to
release input devices.

Part-of: <https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/1670>
---
 src/backends/meta-backend.c               |  26 +-
 src/backends/meta-cursor-tracker.c.orig   | 507 ++++++++++++++++++++++++++++++
 src/backends/native/meta-backend-native.c |  13 +-
 src/backends/x11/meta-backend-x11.c       |   6 +-
 4 files changed, 537 insertions(+), 15 deletions(-)
 create mode 100644 src/backends/meta-cursor-tracker.c.orig

diff --git a/src/backends/meta-backend.c b/src/backends/meta-backend.c
index a862918..aed54d4 100644
--- a/src/backends/meta-backend.c
+++ b/src/backends/meta-backend.c
@@ -191,12 +191,16 @@ G_DEFINE_ABSTRACT_TYPE_WITH_CODE (MetaBackend, meta_backend, G_TYPE_OBJECT,
                                                          initable_iface_init));
 
 static void
-meta_backend_finalize (GObject *object)
+meta_backend_dispose (GObject *object)
 {
   MetaBackend *backend = META_BACKEND (object);
   MetaBackendPrivate *priv = meta_backend_get_instance_private (backend);
 
-  g_list_free_full (priv->gpus, g_object_unref);
+  if (priv->gpus)
+    {
+      g_list_free_full (priv->gpus, g_object_unref);
+      priv->gpus = NULL;
+    }
 
   g_clear_object (&priv->current_device);
   g_clear_object (&priv->monitor_manager);
@@ -213,9 +217,17 @@ meta_backend_finalize (GObject *object)
 #endif
 
   if (priv->sleep_signal_id)
-    g_dbus_connection_signal_unsubscribe (priv->system_bus, priv->sleep_signal_id);
+    {
+      g_dbus_connection_signal_unsubscribe (priv->system_bus, priv->sleep_signal_id);
+      priv->sleep_signal_id = 0;
+    }
+
   if (priv->upower_watch_id)
-    g_bus_unwatch_name (priv->upower_watch_id);
+    {
+      g_bus_unwatch_name (priv->upower_watch_id);
+      priv->upower_watch_id = 0;
+    }
+
   g_cancellable_cancel (priv->cancellable);
   g_clear_object (&priv->cancellable);
   g_clear_object (&priv->system_bus);
@@ -223,7 +235,7 @@ meta_backend_finalize (GObject *object)
 
   g_clear_handle_id (&priv->device_update_idle_id, g_source_remove);
 
-  g_hash_table_destroy (priv->device_monitors);
+  g_clear_pointer (&priv->device_monitors, g_hash_table_destroy);
 
   g_clear_object (&priv->settings);
 
@@ -233,7 +245,7 @@ meta_backend_finalize (GObject *object)
 
   g_clear_object (&priv->clutter_backend);
 
-  G_OBJECT_CLASS (meta_backend_parent_class)->finalize (object);
+  G_OBJECT_CLASS (meta_backend_parent_class)->dispose (object);
 }
 
 static void
@@ -831,7 +843,7 @@ meta_backend_class_init (MetaBackendClass *klass)
   const gchar *mutter_stage_views;
   GObjectClass *object_class = G_OBJECT_CLASS (klass);
 
-  object_class->finalize = meta_backend_finalize;
+  object_class->dispose = meta_backend_dispose;
   object_class->constructed = meta_backend_constructed;
 
   klass->post_init = meta_backend_real_post_init;
diff --git a/src/backends/meta-cursor-tracker.c.orig b/src/backends/meta-cursor-tracker.c.orig
new file mode 100644
index 0000000..d2bd226
--- /dev/null
+++ b/src/backends/meta-cursor-tracker.c.orig
@@ -0,0 +1,507 @@
+/* -*- mode: C; c-file-style: "gnu"; indent-tabs-mode: nil; -*- */
+
+/*
+ * Copyright 2013 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ *
+ * Author: Giovanni Campagna <gcampagn@redhat.com>
+ */
+
+/**
+ * SECTION:cursor-tracker
+ * @title: MetaCursorTracker
+ * @short_description: Mutter cursor tracking helper. Originally only
+ *                     tracking the cursor image, now more of a "core
+ *                     pointer abstraction"
+ */
+
+#include "config.h"
+
+#include "backends/meta-cursor-tracker-private.h"
+
+#include <string.h>
+
+#include "backends/meta-backend-private.h"
+#include "cogl/cogl.h"
+#include "core/display-private.h"
+#include "clutter/clutter.h"
+#include "meta/main.h"
+#include "meta/util.h"
+
+enum
+{
+  PROP_0,
+
+  PROP_BACKEND,
+
+  N_PROPS
+};
+
+static GParamSpec *obj_props[N_PROPS];
+
+typedef struct _MetaCursorTrackerPrivate
+{
+  MetaBackend *backend;
+
+  gboolean is_showing;
+
+  int track_position_count;
+
+  float x;
+  float y;
+
+  MetaCursorSprite *effective_cursor; /* May be NULL when hidden */
+  MetaCursorSprite *displayed_cursor;
+
+  /* Wayland clients can set a NULL buffer as their cursor
+   * explicitly, which means that we shouldn't display anything.
+   * So, we can't simply store a NULL in window_cursor to
+   * determine an unset window cursor; we need an extra boolean.
+   */
+  gboolean has_window_cursor;
+  MetaCursorSprite *window_cursor;
+
+  MetaCursorSprite *root_cursor;
+} MetaCursorTrackerPrivate;
+
+G_DEFINE_TYPE_WITH_PRIVATE (MetaCursorTracker, meta_cursor_tracker,
+                            G_TYPE_OBJECT)
+
+enum
+{
+  CURSOR_CHANGED,
+  POSITION_INVALIDATED,
+  VISIBILITY_CHANGED,
+  LAST_SIGNAL
+};
+
+static guint signals[LAST_SIGNAL];
+
+void
+meta_cursor_tracker_notify_cursor_changed (MetaCursorTracker *tracker)
+{
+  g_signal_emit (tracker, signals[CURSOR_CHANGED], 0);
+}
+
+static void
+cursor_texture_updated (MetaCursorSprite  *cursor,
+                        MetaCursorTracker *tracker)
+{
+  g_signal_emit (tracker, signals[CURSOR_CHANGED], 0);
+}
+
+static gboolean
+update_displayed_cursor (MetaCursorTracker *tracker)
+{
+  MetaCursorTrackerPrivate *priv =
+    meta_cursor_tracker_get_instance_private (tracker);
+  MetaDisplay *display = meta_get_display ();
+  MetaCursorSprite *cursor = NULL;
+
+  if (display && meta_display_windows_are_interactable (display) &&
+      priv->has_window_cursor)
+    cursor = priv->window_cursor;
+  else
+    cursor = priv->root_cursor;
+
+  if (priv->displayed_cursor == cursor)
+    return FALSE;
+
+  if (priv->displayed_cursor)
+    {
+      g_signal_handlers_disconnect_by_func (priv->displayed_cursor,
+                                            cursor_texture_updated,
+                                            tracker);
+    }
+
+  g_set_object (&priv->displayed_cursor, cursor);
+
+  if (cursor)
+    {
+      g_signal_connect (cursor, "texture-changed",
+                        G_CALLBACK (cursor_texture_updated), tracker);
+    }
+
+  return TRUE;
+}
+
+static gboolean
+update_effective_cursor (MetaCursorTracker *tracker)
+{
+  MetaCursorTrackerPrivate *priv =
+    meta_cursor_tracker_get_instance_private (tracker);
+  MetaCursorSprite *cursor = NULL;
+
+  if (priv->is_showing)
+    cursor = priv->displayed_cursor;
+
+  return g_set_object (&priv->effective_cursor, cursor);
+}
+
+static void
+change_cursor_renderer (MetaCursorTracker *tracker)
+{
+  MetaCursorTrackerPrivate *priv =
+    meta_cursor_tracker_get_instance_private (tracker);
+  MetaCursorRenderer *cursor_renderer =
+    meta_backend_get_cursor_renderer (priv->backend);
+
+  meta_cursor_renderer_set_cursor (cursor_renderer, priv->effective_cursor);
+}
+
+static void
+sync_cursor (MetaCursorTracker *tracker)
+{
+  gboolean cursor_changed = FALSE;
+
+  cursor_changed = update_displayed_cursor (tracker);
+
+  if (update_effective_cursor (tracker))
+    change_cursor_renderer (tracker);
+
+  if (cursor_changed)
+    g_signal_emit (tracker, signals[CURSOR_CHANGED], 0);
+}
+
+static void
+meta_cursor_tracker_real_set_force_track_position (MetaCursorTracker *tracker,
+                                                   gboolean           is_enabled)
+{
+}
+
+static MetaCursorSprite *
+meta_cursor_tracker_real_get_sprite (MetaCursorTracker *tracker)
+{
+  MetaCursorTrackerPrivate *priv =
+    meta_cursor_tracker_get_instance_private (tracker);
+
+  return priv->displayed_cursor;
+}
+
+static void
+meta_cursor_tracker_init (MetaCursorTracker *tracker)
+{
+  MetaCursorTrackerPrivate *priv =
+    meta_cursor_tracker_get_instance_private (tracker);
+
+  priv->is_showing = FALSE;
+  priv->x = -1.0;
+  priv->y = -1.0;
+}
+
+static void
+meta_cursor_tracker_get_property (GObject    *object,
+                                  guint       prop_id,
+                                  GValue     *value,
+                                  GParamSpec *pspec)
+{
+  MetaCursorTracker *tracker = META_CURSOR_TRACKER (object);
+  MetaCursorTrackerPrivate *priv =
+    meta_cursor_tracker_get_instance_private (tracker);
+
+  switch (prop_id)
+    {
+    case PROP_BACKEND:
+      g_value_set_object (value, priv->backend);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+    }
+}
+
+static void
+meta_cursor_tracker_set_property (GObject      *object,
+                                  guint         prop_id,
+                                  const GValue *value,
+                                  GParamSpec   *pspec)
+{
+  MetaCursorTracker *tracker = META_CURSOR_TRACKER (object);
+  MetaCursorTrackerPrivate *priv =
+    meta_cursor_tracker_get_instance_private (tracker);
+
+  switch (prop_id)
+    {
+    case PROP_BACKEND:
+      priv->backend = g_value_get_object (value);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+    }
+}
+
+static void
+meta_cursor_tracker_finalize (GObject *object)
+{
+  MetaCursorTracker *tracker = META_CURSOR_TRACKER (object);
+  MetaCursorTrackerPrivate *priv =
+    meta_cursor_tracker_get_instance_private (tracker);
+
+  g_clear_object (&priv->effective_cursor);
+  g_clear_object (&priv->displayed_cursor);
+  g_clear_object (&priv->root_cursor);
+
+  G_OBJECT_CLASS (meta_cursor_tracker_parent_class)->finalize (object);
+}
+
+static void
+meta_cursor_tracker_class_init (MetaCursorTrackerClass *klass)
+{
+  GObjectClass *object_class = G_OBJECT_CLASS (klass);
+
+  object_class->get_property = meta_cursor_tracker_get_property;
+  object_class->set_property = meta_cursor_tracker_set_property;
+  object_class->finalize = meta_cursor_tracker_finalize;
+
+  klass->set_force_track_position =
+    meta_cursor_tracker_real_set_force_track_position;
+  klass->get_sprite =
+    meta_cursor_tracker_real_get_sprite;
+
+  obj_props[PROP_BACKEND] =
+    g_param_spec_object ("backend",
+                         "backend",
+                         "MetaBackend",
+                         META_TYPE_BACKEND,
+                         G_PARAM_READWRITE |
+                         G_PARAM_CONSTRUCT_ONLY |
+                         G_PARAM_STATIC_STRINGS);
+  g_object_class_install_properties (object_class, N_PROPS, obj_props);
+
+  signals[CURSOR_CHANGED] = g_signal_new ("cursor-changed",
+                                          G_TYPE_FROM_CLASS (klass),
+                                          G_SIGNAL_RUN_LAST,
+                                          0,
+                                          NULL, NULL, NULL,
+                                          G_TYPE_NONE, 0);
+
+  signals[POSITION_INVALIDATED] = g_signal_new ("position-invalidated",
+                                                G_TYPE_FROM_CLASS (klass),
+                                                G_SIGNAL_RUN_LAST,
+                                                0,
+                                                NULL, NULL, NULL,
+                                                G_TYPE_NONE, 0);
+
+  signals[VISIBILITY_CHANGED] = g_signal_new ("visibility-changed",
+                                              G_TYPE_FROM_CLASS (klass),
+                                              G_SIGNAL_RUN_LAST,
+                                              0, NULL, NULL, NULL,
+                                              G_TYPE_NONE, 0);
+}
+
+/**
+ * meta_cursor_tracker_get_for_display:
+ * @display: the #MetaDisplay
+ *
+ * Retrieves the cursor tracker object for @display.
+ *
+ * Returns: (transfer none):
+ */
+MetaCursorTracker *
+meta_cursor_tracker_get_for_display (MetaDisplay *display)
+{
+  MetaBackend *backend = meta_get_backend ();
+  MetaCursorTracker *tracker = meta_backend_get_cursor_tracker (backend);
+
+  g_assert (tracker);
+
+  return tracker;
+}
+
+static void
+set_window_cursor (MetaCursorTracker *tracker,
+                   gboolean           has_cursor,
+                   MetaCursorSprite  *cursor_sprite)
+{
+  MetaCursorTrackerPrivate *priv =
+    meta_cursor_tracker_get_instance_private (tracker);
+
+  g_clear_object (&priv->window_cursor);
+  if (cursor_sprite)
+    priv->window_cursor = g_object_ref (cursor_sprite);
+  priv->has_window_cursor = has_cursor;
+  sync_cursor (tracker);
+}
+
+/**
+ * meta_cursor_tracker_get_sprite:
+ *
+ * Returns: (transfer none):
+ */
+CoglTexture *
+meta_cursor_tracker_get_sprite (MetaCursorTracker *tracker)
+{
+  MetaCursorSprite *cursor_sprite;
+
+  cursor_sprite = META_CURSOR_TRACKER_GET_CLASS (tracker)->get_sprite (tracker);
+
+  if (!cursor_sprite)
+    return NULL;
+
+  meta_cursor_sprite_realize_texture (cursor_sprite);
+  return meta_cursor_sprite_get_cogl_texture (cursor_sprite);
+}
+
+/**
+ * meta_cursor_tracker_get_hot:
+ * @tracker:
+ * @x: (out):
+ * @y: (out):
+ *
+ */
+void
+meta_cursor_tracker_get_hot (MetaCursorTracker *tracker,
+                             int               *x,
+                             int               *y)
+{
+  MetaCursorSprite *cursor_sprite;
+
+  g_return_if_fail (META_IS_CURSOR_TRACKER (tracker));
+
+  cursor_sprite = META_CURSOR_TRACKER_GET_CLASS (tracker)->get_sprite (tracker);
+
+  if (cursor_sprite)
+    meta_cursor_sprite_get_hotspot (cursor_sprite, x, y);
+  else
+    {
+      if (x)
+        *x = 0;
+      if (y)
+        *y = 0;
+    }
+}
+
+void
+meta_cursor_tracker_set_window_cursor (MetaCursorTracker *tracker,
+                                       MetaCursorSprite  *cursor_sprite)
+{
+  set_window_cursor (tracker, TRUE, cursor_sprite);
+}
+
+void
+meta_cursor_tracker_unset_window_cursor (MetaCursorTracker *tracker)
+{
+  set_window_cursor (tracker, FALSE, NULL);
+}
+
+/**
+ * meta_cursor_tracker_set_root_cursor:
+ * @tracker: a #MetaCursorTracker object.
+ * @cursor_sprite: (transfer none): the new root cursor
+ *
+ * Sets the root cursor (the cursor that is shown if not modified by a window).
+ * The #MetaCursorTracker will take a strong reference to the sprite.
+ */
+void
+meta_cursor_tracker_set_root_cursor (MetaCursorTracker *tracker,
+                                     MetaCursorSprite  *cursor_sprite)
+{
+  MetaCursorTrackerPrivate *priv =
+    meta_cursor_tracker_get_instance_private (tracker);
+
+  g_clear_object (&priv->root_cursor);
+  if (cursor_sprite)
+    priv->root_cursor = g_object_ref (cursor_sprite);
+
+  sync_cursor (tracker);
+}
+
+void
+meta_cursor_tracker_invalidate_position (MetaCursorTracker *tracker)
+{
+  g_signal_emit (tracker, signals[POSITION_INVALIDATED], 0);
+}
+
+void
+meta_cursor_tracker_get_pointer (MetaCursorTracker   *tracker,
+                                 graphene_point_t    *coords,
+                                 ClutterModifierType *mods)
+{
+  ClutterSeat *seat;
+  ClutterInputDevice *cdevice;
+
+  seat = clutter_backend_get_default_seat (clutter_get_default_backend ());
+  cdevice = clutter_seat_get_pointer (seat);
+
+  clutter_seat_query_state (seat, cdevice, NULL, coords, mods);
+}
+
+void
+meta_cursor_tracker_track_position (MetaCursorTracker *tracker)
+{
+  MetaCursorTrackerPrivate *priv =
+    meta_cursor_tracker_get_instance_private (tracker);
+
+  priv->track_position_count++;
+  if (priv->track_position_count == 1)
+    {
+      MetaCursorTrackerClass *klass =
+        META_CURSOR_TRACKER_GET_CLASS (tracker);
+
+      klass->set_force_track_position (tracker, TRUE);
+    }
+}
+
+void
+meta_cursor_tracker_untrack_position (MetaCursorTracker *tracker)
+{
+  MetaCursorTrackerPrivate *priv =
+    meta_cursor_tracker_get_instance_private (tracker);
+
+  g_return_if_fail (priv->track_position_count > 0);
+
+  priv->track_position_count--;
+  if (priv->track_position_count == 0)
+    {
+      MetaCursorTrackerClass *klass =
+        META_CURSOR_TRACKER_GET_CLASS (tracker);
+
+      klass->set_force_track_position (tracker, FALSE);
+    }
+}
+
+gboolean
+meta_cursor_tracker_get_pointer_visible (MetaCursorTracker *tracker)
+{
+  MetaCursorTrackerPrivate *priv =
+    meta_cursor_tracker_get_instance_private (tracker);
+
+  return priv->is_showing;
+}
+
+void
+meta_cursor_tracker_set_pointer_visible (MetaCursorTracker *tracker,
+                                         gboolean           visible)
+{
+  MetaCursorTrackerPrivate *priv =
+    meta_cursor_tracker_get_instance_private (tracker);
+
+  if (visible == priv->is_showing)
+    return;
+  priv->is_showing = visible;
+
+  sync_cursor (tracker);
+
+  g_signal_emit (tracker, signals[VISIBILITY_CHANGED], 0);
+}
+MetaBackend *
+meta_cursor_tracker_get_backend (MetaCursorTracker *tracker)
+{
+  MetaCursorTrackerPrivate *priv =
+    meta_cursor_tracker_get_instance_private (tracker);
+
+  return priv->backend;
+}
diff --git a/src/backends/native/meta-backend-native.c b/src/backends/native/meta-backend-native.c
index f34b1d2..c794891 100644
--- a/src/backends/native/meta-backend-native.c
+++ b/src/backends/native/meta-backend-native.c
@@ -89,18 +89,21 @@ static void
 disconnect_udev_device_added_handler (MetaBackendNative *native);
 
 static void
-meta_backend_native_finalize (GObject *object)
+meta_backend_native_dispose (GObject *object)
 {
   MetaBackendNative *native = META_BACKEND_NATIVE (object);
 
   if (native->udev_device_added_handler_id)
-    disconnect_udev_device_added_handler (native);
+    {
+      disconnect_udev_device_added_handler (native);
+      native->udev_device_added_handler_id = 0;
+    }
 
   g_clear_object (&native->udev);
   g_clear_object (&native->kms);
-  meta_launcher_free (native->launcher);
+  g_clear_pointer (&native->launcher, meta_launcher_free);
 
-  G_OBJECT_CLASS (meta_backend_native_parent_class)->finalize (object);
+  G_OBJECT_CLASS (meta_backend_native_parent_class)->dispose (object);
 }
 
 static ClutterBackend *
@@ -521,7 +524,7 @@ meta_backend_native_class_init (MetaBackendNativeClass *klass)
   MetaBackendClass *backend_class = META_BACKEND_CLASS (klass);
   GObjectClass *object_class = G_OBJECT_CLASS (klass);
 
-  object_class->finalize = meta_backend_native_finalize;
+  object_class->dispose = meta_backend_native_dispose;
 
   backend_class->create_clutter_backend = meta_backend_native_create_clutter_backend;
 
diff --git a/src/backends/x11/meta-backend-x11.c b/src/backends/x11/meta-backend-x11.c
index cde8803..e1a520b 100644
--- a/src/backends/x11/meta-backend-x11.c
+++ b/src/backends/x11/meta-backend-x11.c
@@ -848,7 +848,7 @@ initable_iface_init (GInitableIface *initable_iface)
 }
 
 static void
-meta_backend_x11_finalize (GObject *object)
+meta_backend_x11_dispose (GObject *object)
 {
   MetaBackend *backend = META_BACKEND (object);
   MetaBackendX11 *x11 = META_BACKEND_X11 (object);
@@ -871,7 +871,7 @@ meta_backend_x11_finalize (GObject *object)
       priv->user_active_alarm = None;
     }
 
-  G_OBJECT_CLASS (meta_backend_x11_parent_class)->finalize (object);
+  G_OBJECT_CLASS (meta_backend_x11_parent_class)->dispose (object);
 }
 
 static void
@@ -880,7 +880,7 @@ meta_backend_x11_class_init (MetaBackendX11Class *klass)
   MetaBackendClass *backend_class = META_BACKEND_CLASS (klass);
   GObjectClass *object_class = G_OBJECT_CLASS (klass);
 
-  object_class->finalize = meta_backend_x11_finalize;
+  object_class->dispose = meta_backend_x11_dispose;
   backend_class->create_clutter_backend = meta_backend_x11_create_clutter_backend;
   backend_class->post_init = meta_backend_x11_post_init;
   backend_class->grab_device = meta_backend_x11_grab_device;
