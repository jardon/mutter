From: Carlos Garnacho <carlosg@gnome.org>
Date: Thu, 22 Oct 2020 11:23:03 +0200
Subject: backends/native: Assign unique ranges of slots to virtual devices

We are moving to seat-wide touch slot accounting, so move these virtual
devices to using their own range each. The theoretical case of
overflow/rollover is also handled.

https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/1486
---
 src/backends/native/meta-seat-native.c             | 38 ++++++++++++++++++++++
 src/backends/native/meta-seat-native.h             |  5 +++
 .../native/meta-virtual-input-device-native.c      | 29 +++++++++++++++--
 3 files changed, 69 insertions(+), 3 deletions(-)

diff --git a/src/backends/native/meta-seat-native.c b/src/backends/native/meta-seat-native.c
index d73068f..166a80d 100644
--- a/src/backends/native/meta-seat-native.c
+++ b/src/backends/native/meta-seat-native.c
@@ -2579,6 +2579,7 @@ meta_seat_native_finalize (GObject *object)
     }
   g_slist_free (seat->devices);
   g_free (seat->touch_states);
+  g_hash_table_destroy (seat->reserved_virtual_slots);
 
   g_object_unref (seat->udev_client);
 
@@ -2676,16 +2677,51 @@ meta_seat_native_apply_kbd_a11y_settings (ClutterSeat            *seat,
                                                       settings);
 }
 
+static guint
+bump_virtual_touch_slot_base (MetaSeatNative *seat_native)
+{
+  while (TRUE)
+    {
+      if (seat_native->virtual_touch_slot_base < 0x100)
+        seat_native->virtual_touch_slot_base = 0x100;
+
+      seat_native->virtual_touch_slot_base +=
+        CLUTTER_VIRTUAL_INPUT_DEVICE_MAX_TOUCH_SLOTS;
+
+      if (!g_hash_table_lookup (seat_native->reserved_virtual_slots,
+                                GUINT_TO_POINTER (seat_native->virtual_touch_slot_base)))
+        break;
+    }
+
+  return seat_native->virtual_touch_slot_base;
+}
+
 static ClutterVirtualInputDevice *
 meta_seat_native_create_virtual_device (ClutterSeat            *seat,
                                         ClutterInputDeviceType  device_type)
 {
+  MetaSeatNative *seat_native = META_SEAT_NATIVE (seat);
+  guint slot_base;
+
+  slot_base = bump_virtual_touch_slot_base (seat_native);
+  g_hash_table_add (seat_native->reserved_virtual_slots,
+                    GUINT_TO_POINTER (slot_base));
+
   return g_object_new (META_TYPE_VIRTUAL_INPUT_DEVICE_NATIVE,
                        "seat", seat,
+                       "slot-base", slot_base,
                        "device-type", device_type,
                        NULL);
 }
 
+void
+meta_seat_native_release_touch_slots (MetaSeatNative *seat,
+                                      guint           base_slot)
+{
+  g_hash_table_remove (seat->reserved_virtual_slots,
+                       GUINT_TO_POINTER (base_slot));
+}
+
 static ClutterVirtualDeviceType
 meta_seat_native_get_supported_virtual_device_types (ClutterSeat *seat)
 {
@@ -2830,6 +2866,8 @@ meta_seat_native_init (MetaSeatNative *seat)
   seat->repeat = TRUE;
   seat->repeat_delay = 250;     /* ms */
   seat->repeat_interval = 33;   /* ms */
+
+  seat->reserved_virtual_slots = g_hash_table_new (NULL, NULL);
 }
 
 void
diff --git a/src/backends/native/meta-seat-native.h b/src/backends/native/meta-seat-native.h
index 7945603..2724730 100644
--- a/src/backends/native/meta-seat-native.h
+++ b/src/backends/native/meta-seat-native.h
@@ -90,6 +90,8 @@ struct _MetaSeatNative
 
   MetaTouchState **touch_states;
   int n_alloc_touch_states;
+  guint virtual_touch_slot_base;
+  GHashTable *reserved_virtual_slots;
 
   struct xkb_state *xkb;
   xkb_led_index_t caps_lock_led;
@@ -288,4 +290,7 @@ void meta_seat_native_set_keyboard_repeat (MetaSeatNative *seat,
                                            uint32_t        delay,
                                            uint32_t        interval);
 
+void meta_seat_native_release_touch_slots (MetaSeatNative *seat,
+                                           guint           base_slot);
+
 #endif /* META_SEAT_NATIVE_H */
diff --git a/src/backends/native/meta-virtual-input-device-native.c b/src/backends/native/meta-virtual-input-device-native.c
index 9326fc0..4b545fe 100644
--- a/src/backends/native/meta-virtual-input-device-native.c
+++ b/src/backends/native/meta-virtual-input-device-native.c
@@ -34,6 +34,7 @@ enum
   PROP_0,
 
   PROP_SEAT,
+  PROP_SLOT_BASE,
 
   PROP_LAST
 };
@@ -46,6 +47,7 @@ struct _MetaVirtualInputDeviceNative
 
   ClutterInputDevice *device;
   MetaSeatNative *seat;
+  guint slot_base;
   int button_count[KEY_CNT];
 };
 
@@ -547,14 +549,16 @@ meta_virtual_input_device_native_notify_touch_down (ClutterVirtualInputDevice *v
   MetaInputDeviceNative *device_evdev =
     META_INPUT_DEVICE_NATIVE (virtual_evdev->device);
   MetaTouchState *touch_state;
+  guint seat_slot;
 
   g_return_if_fail (virtual_evdev->device != NULL);
 
   if (time_us == CLUTTER_CURRENT_TIME)
     time_us = g_get_monotonic_time ();
 
+  seat_slot = virtual_evdev->slot_base + (guint) device_slot;
   touch_state = meta_input_device_native_acquire_touch_state (device_evdev,
-                                                              device_slot);
+                                                              seat_slot);
   if (!touch_state)
     return;
 
@@ -582,14 +586,16 @@ meta_virtual_input_device_native_notify_touch_motion (ClutterVirtualInputDevice
   MetaInputDeviceNative *device_evdev =
     META_INPUT_DEVICE_NATIVE (virtual_evdev->device);
   MetaTouchState *touch_state;
+  guint seat_slot;
 
   g_return_if_fail (virtual_evdev->device != NULL);
 
   if (time_us == CLUTTER_CURRENT_TIME)
     time_us = g_get_monotonic_time ();
 
+  seat_slot = virtual_evdev->slot_base + (guint) device_slot;
   touch_state = meta_input_device_native_lookup_touch_state (device_evdev,
-                                                             device_slot);
+                                                             seat_slot);
   if (!touch_state)
     return;
 
@@ -615,14 +621,16 @@ meta_virtual_input_device_native_notify_touch_up (ClutterVirtualInputDevice *vir
   MetaInputDeviceNative *device_evdev =
     META_INPUT_DEVICE_NATIVE (virtual_evdev->device);
   MetaTouchState *touch_state;
+  guint seat_slot;
 
   g_return_if_fail (virtual_evdev->device != NULL);
 
   if (time_us == CLUTTER_CURRENT_TIME)
     time_us = g_get_monotonic_time ();
 
+  seat_slot = virtual_evdev->slot_base + (guint) device_slot;
   touch_state = meta_input_device_native_lookup_touch_state (device_evdev,
-                                                             device_slot);
+                                                             seat_slot);
   if (!touch_state)
     return;
 
@@ -651,6 +659,9 @@ meta_virtual_input_device_native_get_property (GObject    *object,
     case PROP_SEAT:
       g_value_set_pointer (value, virtual_evdev->seat);
       break;
+    case PROP_SLOT_BASE:
+      g_value_set_uint (value, virtual_evdev->slot_base);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -671,6 +682,9 @@ meta_virtual_input_device_native_set_property (GObject      *object,
     case PROP_SEAT:
       virtual_evdev->seat = g_value_get_pointer (value);
       break;
+    case PROP_SLOT_BASE:
+      virtual_evdev->slot_base = g_value_get_uint (value);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -726,6 +740,9 @@ meta_virtual_input_device_native_dispose (GObject *object)
       g_clear_object (&virtual_evdev->device);
     }
 
+  meta_seat_native_release_touch_slots (virtual_evdev->seat,
+                                        virtual_evdev->slot_base);
+
   object_class->dispose (object);
 }
 
@@ -762,5 +779,11 @@ meta_virtual_input_device_native_class_init (MetaVirtualInputDeviceNativeClass *
                                                "Seat",
                                                CLUTTER_PARAM_READWRITE |
                                                G_PARAM_CONSTRUCT_ONLY);
+  obj_props[PROP_SLOT_BASE] = g_param_spec_uint ("slot-base",
+                                                 "Slot base",
+                                                 "Base for touch slots",
+                                                 0, G_MAXUINT, 0,
+                                                 CLUTTER_PARAM_READWRITE |
+                                                 G_PARAM_CONSTRUCT_ONLY);
   g_object_class_install_properties (object_class, PROP_LAST, obj_props);
 }
