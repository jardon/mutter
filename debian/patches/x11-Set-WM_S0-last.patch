From: Olivier Fourdan <ofourdan@redhat.com>
Date: Wed, 9 Mar 2022 14:41:13 +0100
Subject: x11: Set WM_S0 last

With Xwayland on demand, a number of maintenance X11 applications need
to be run first, before Xwayland starts accepting requests from the
normal clients, as soon as the WM_S0 selection is acquired by mutter.

On startup, mutter also sets a number of X11 properties that can be
queried by X11 clients.

Unfortunately, mutter acquires the WM_S0 selection before setting those
properties, so mutter and the first regular X11 client will race on
startup.

As a result, the X11 properties set by mutter on startup may not be
available to the very first X11 client when Xwayland starts.

To avoid that issue, make sure to take the WM_S0 selection last when
opening the display.

Closes: https://gitlab.gnome.org/GNOME/mutter/-/issues/2176
Part-of: <https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/2336>

Origin: https://gitlab.gnome.org/GNOME/mutter/-/commit/eb4307c3
---
 src/x11/meta-x11-display.c | 42 +++++++++++++++++++++++-------------------
 1 file changed, 23 insertions(+), 19 deletions(-)

diff --git a/src/x11/meta-x11-display.c b/src/x11/meta-x11-display.c
index d4b5ff4..5343633 100644
--- a/src/x11/meta-x11-display.c
+++ b/src/x11/meta-x11-display.c
@@ -1303,25 +1303,6 @@ meta_x11_display_new (MetaDisplay *display, GError **error)
                                               xroot,
                                               PropertyChangeMask);
 
-  sprintf (buf, "WM_S%d", number);
-
-  wm_sn_atom = XInternAtom (xdisplay, buf, False);
-  new_wm_sn_owner = take_manager_selection (x11_display, xroot, wm_sn_atom, timestamp, replace_current_wm);
-  if (new_wm_sn_owner == None)
-    {
-      g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
-                   "Failed to acquire window manager ownership");
-
-      g_object_run_dispose (G_OBJECT (x11_display));
-      g_clear_object (&x11_display);
-
-      return NULL;
-    }
-
-  x11_display->wm_sn_selection_window = new_wm_sn_owner;
-  x11_display->wm_sn_atom = wm_sn_atom;
-  x11_display->wm_sn_timestamp = timestamp;
-
   init_event_masks (x11_display);
 
   /* Select for cursor changes so the cursor tracker is up to date. */
@@ -1418,6 +1399,29 @@ meta_x11_display_new (MetaDisplay *display, GError **error)
   if (!meta_is_wayland_compositor ())
     meta_dnd_init_xdnd (x11_display);
 
+  sprintf (buf, "WM_S%d", number);
+
+  wm_sn_atom = XInternAtom (xdisplay, buf, False);
+  new_wm_sn_owner = take_manager_selection (x11_display,
+                                            xroot,
+                                            wm_sn_atom,
+                                            timestamp,
+                                            replace_current_wm);
+  if (new_wm_sn_owner == None)
+    {
+      g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
+                   "Failed to acquire window manager ownership");
+
+      g_object_run_dispose (G_OBJECT (x11_display));
+      g_clear_object (&x11_display);
+
+      return NULL;
+    }
+
+  x11_display->wm_sn_selection_window = new_wm_sn_owner;
+  x11_display->wm_sn_atom = wm_sn_atom;
+  x11_display->wm_sn_timestamp = timestamp;
+
   return x11_display;
 }
 
